
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>Paillier Example</title>
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="https://storage.googleapis.com/codelab-elements/codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
</head>
<body>
  <google-codelab-analytics gaid="UA-49880327-14"></google-codelab-analytics>
  <google-codelab codelab-gaid=""
                  id="paillier-example"
                  title="Paillier Example"
                  environment="web"
                  feedback-link="https://github.com/InspiringGroupCodelabs/InspiringGroupCodelabs.github.io/issues">
    
      <google-codelab-step label="Overview" duration="1">
        <p>A homomorphic encryption scheme, generally, allows one to compute on ciphertexts, where the plaintexts are not known, and get a new ciphertext which is the encryption of the result generated by some operation on the original plaintext.</p>
<p>Pascal Paillier introduced a <em>partially</em> HE scheme in 1999, which supports the multiplication over ciphertexts corresponding to addition over plaintexts.</p>
<p>In the following steps, we will implement a simple Paillier crytosystem and test its functionality.</p>
<h2 is-upgraded>You will learn to code</h2>
<ul>
<li>The math utilities that underlies the Paillier Encryption scheme</li>
<li>Key generation steps</li>
<li>Encryption and decryption</li>
<li>Evaluation of addition</li>
<li>Test the implementation</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Math basics" duration="2">
        <p>First we implement quick-power, extended Euclidean Algorithm, and a function to get the multiplication inverse under some modulo.</p>
<pre><code language="language-python" class="language-python">  import random
  import math

  # quick power: calculate (base^exponent)%modulus
  def powerMod(base, exponent, modulus):
    answer = 1
    while exponent &gt; 0:
      if exponent % 2 == 1: answer = (answer * base) % modulus
      base = (base**2) % modulus
      exponent //= 2
    return answer

  # exgcd: return (x, y, gcd(a, b)) where ax + by = gcd(a,b)
  def exgcd(a, b):
    if b == 0: return 1, 0, a
    else:
      x0, y0, g = exgcd(b, a%b)
      return y0, x0 - (a//b)*y0, g

  # inv: return x, where ax = 1 (mod m)
  def inv(a, m) -&gt; int:
      x, y, g = exgcd(a, m)
      return (x%m+m)%m
</code></pre>
<p>As the key generation uses large primes, we use the Sieve of Eratosthenes to calculate a list of primes for simplicity.</p>
<pre><code language="language-python" class="language-python">  def sieve(upperbound = 0x4000):
    primes = []
    flags = [True] * upperbound
    for each in range(2, upperbound):
      if not flags[each]: continue
      for multiplier in range(2, upperbound // each):
        flags[multiplier * each] = False
      primes.append(each)
    return primes

  primes = sieve(0x4000)
</code></pre>
<aside class="special"><p>Empirically, to find a prime great enough, <strong>Miller-Rabin primality test</strong> is usually used. Its essence is to generate randomly a number and if the number passes some simple mathematical tests, it can be treated as a prime number with a high probability.</p>
</aside>


      </google-codelab-step>
    
      <google-codelab-step label="Key generation" duration="1">
        <p>The generation of keys requires two randomly sampled large primes.</p>
<pre><code language="language-python" class="language-python">  # produce (n, g, lambda, mu), where (n, g) is the public key, (lambda, mu) is the private key
  def generateKeys():
    primeCount = len(primes)
    p = primes[random.randint(primeCount // 2, primeCount)]
    while True:
      q = primes[random.randint(primeCount // 2, primeCount)]
      if p != q: break
    n = p*q
    Lambda = (p-1)*(q-1) // math.gcd(p-1, q-1)
    g = n + 1
    mu = inv((powerMod(g, Lambda, n*n)-1)//n, n)
    return n, g, Lambda, mu
</code></pre>
<aside class="special"><p>Empirically, as <code>g</code> is public, we need not choose it <em>randomly</em>. For example we can actually set <code>g = n+1</code>.</p>
</aside>


      </google-codelab-step>
    
      <google-codelab-step label="Encryption and Decryption" duration="0">
        <p>Encryption needs the public keys, while decrpytion needs the private key, generated in the previous section.</p>
<pre><code language="language-python" class="language-python">  def encrypt(m, n, g):
    while True:
      r = random.randint(1, n-1)
      if math.gcd(r, n) == 1: break
    c = powerMod(g, m, n*n) * powerMod(r, n, n*n) % (n*n)
    return c

  def decrypt(c, Lambda, mu, n):
    k = powerMod(c, Lambda, n*n)
    assert((k-1)%n == 0) # when (k-1)%n != 0, c is not a valid ciphertext.
    return (k-1)//n * mu % n  
</code></pre>
<aside class="special"><p>Actually, when doing encryption if <code>n</code> is large enough, we can uniformly samples a <code>0 < r < n</code>, for it is very unlikely that the two numbers are not coprime.</p>
</aside>


      </google-codelab-step>
    
      <google-codelab-step label="Evaluation of the Addition Operation" duration="0">
        <p>Simple as it might be, the evaluation of addition is reflected on the ciphertext space as the multiplication with modulo.</p>
<pre><code language="language-python" class="language-python">  def evalAdd(c1, c2, n):
    return c1 * c2 % (n*n)
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="Test the implementation" duration="0">
        <p>With the codes above, we can test the correctness of our implementation.</p>
<pre><code language="language-python" class="language-python">  # generate keys
  n, g, Lambda, mu = generateKeys()
  print(f&#34;Public key:       n = {n:10d},  g = {g:10d}&#34;)
  print(f&#34;Private key: lambda = {Lambda:10d}, mu = {mu:10d}&#34;)

  # plaintext
  m1 = random.randint(0, n-1)
  m2 = random.randint(0, n-1)

  # ciphertext
  c1 = encrypt(m1, n, g)
  c2 = encrypt(m2, n, g)
  print(f&#34;c1 = Encrypt({m1}) = {c1:18d} = 0x{c1:015x}&#34;)
  print(f&#34;c2 = Encrypt({m2}) = {c2:18d} = 0x{c2:015x}&#34;)

  # evaluate addition
  c3 = evalAdd(c1, c2, n)
  print(f&#34;c3 = c1 * c2 = {c3:18d} = 0x{c3:015x}&#34;)

  # decrypt
  d = decrypt(c3, Lambda, mu, n)
  print(f&#34;Decrypt(c3) = {d} = {m1} + {m2} (mod {n})&#34;)
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="Markdown tests" duration="0">
        <p>Quotes</p>
<p>Hello this is some quote</p>
<p>Inline codes</p>
<p>The quick <code>brown</code> fox jumps over the lazy dog.</p>
<p>Math expressions</p>
<p>Inline: $(a+b)^2 = a^2 + 2ab + b^2$</p>
<p>Block $$ \begin{aligned} (a+b)^3 &amp; = (a+b)(a^2+2ab+b^2) \ &amp; = a^3 + 3a^2b + 3ab^2 + b^3 \end{aligned}$$</p>
<p>Raw html</p>
<p>The quick brown fox jumps over a lazy dog.</p>


      </google-codelab-step>
    
  </google-codelab>

  <script src="https://storage.googleapis.com/codelab-elements/native-shim.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/custom-elements.min.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/prettify.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/codelab-elements.js"></script>
  <script src="//support.google.com/inapp/api.js"></script>

</body>
</html>

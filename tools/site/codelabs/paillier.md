summary: A simple implementation of Paillier cryptosystem.
id: paillier-example
categories:   appliedcryptography
tags:   appliedcryptography
status: Published
authors:   Liu Xuanqi
Feedback Link:   https://github.com/InspiringGroupCodelabs/InspiringGroupCodelabs.github.io/issues

# Paillier Example

<!-- ------------------------ -->
## Overview 
Duration: 1

A homomorphic encryption scheme, generally, allows one to compute on ciphertexts, where the plaintexts are not known, and get a new ciphertext which is the encryption of the result generated by some operation on the original plaintext.

Pascal Paillier introduced a *partially* HE scheme in 1999, which supports the multiplication over ciphertexts corresponding to addition over plaintexts.

In the following steps, we will implement a simple Paillier crytosystem and test its functionality.

### You will learn to code

- The math utilities that underlies the Paillier Encryption scheme
- Key generation steps
- Encryption and decryption
- Evaluation of addition
- Test the implementation

<!-- ------------------------ -->
## Math basics
Duration: 2

First we implement quick-power, extended Euclidean Algorithm, and a function to get the multiplication inverse under some modulo. 

```python
  import random
  import math

  # quick power: calculate (base^exponent)%modulus
  def powerMod(base, exponent, modulus):
    answer = 1
    while exponent > 0:
      if exponent % 2 == 1: answer = (answer * base) % modulus
      base = (base**2) % modulus
      exponent //= 2
    return answer

  # exgcd: return (x, y, gcd(a, b)) where ax + by = gcd(a,b)
  def exgcd(a, b):
    if b == 0: return 1, 0, a
    else:
      x0, y0, g = exgcd(b, a%b)
      return y0, x0 - (a//b)*y0, g

  # inv: return x, where ax = 1 (mod m)
  def inv(a, m) -> int:
      x, y, g = exgcd(a, m)
      return (x%m+m)%m
```

As the key generation uses large primes, we use the Sieve of Eratosthenes to calculate a list of primes for simplicity. 

```python
  def sieve(upperbound = 0x4000):
    primes = []
    flags = [True] * upperbound
    for each in range(2, upperbound):
      if not flags[each]: continue
      for multiplier in range(2, upperbound // each):
        flags[multiplier * each] = False
      primes.append(each)
    return primes

  primes = sieve(0x4000)
```

Positive
: Empirically, to find a prime great enough, **Miller-Rabin primality test** is usually used. Its essence is to generate randomly a number and if the number passes some simple mathematical tests, it can be treated as a prime number with a high probability. 

---------------------------------------

<!-- ------------------------ -->
## Key generation
Duration: 1

The generation of keys requires two randomly sampled large primes.

```python
  # produce (n, g, lambda, mu), where (n, g) is the public key, (lambda, mu) is the private key
  def generateKeys():
    primeCount = len(primes)
    p = primes[random.randint(primeCount // 2, primeCount)]
    while True:
      q = primes[random.randint(primeCount // 2, primeCount)]
      if p != q: break
    n = p*q
    Lambda = (p-1)*(q-1) // math.gcd(p-1, q-1)
    g = n + 1
    mu = inv((powerMod(g, Lambda, n*n)-1)//n, n)
    return n, g, Lambda, mu
```

Positive
: Empirically, as `g` is public, we need not choose it *randomly*. For example we can actually set `g = n+1`.

<!-- ------------------------ -->
## Encryption and Decryption

Encryption needs the public keys, while decrpytion needs the private key, generated in the previous section.

```python
  def encrypt(m, n, g):
    while True:
      r = random.randint(1, n-1)
      if math.gcd(r, n) == 1: break
    c = powerMod(g, m, n*n) * powerMod(r, n, n*n) % (n*n)
    return c

  def decrypt(c, Lambda, mu, n):
    k = powerMod(c, Lambda, n*n)
    assert((k-1)%n == 0) # when (k-1)%n != 0, c is not a valid ciphertext.
    return (k-1)//n * mu % n  
```

Positive
: Actually, when doing encryption if `n` is large enough, we can uniformly samples a `0 < r < n`, for it is very unlikely that the two numbers are not coprime.

<!-- ------------------------ -->
## Evaluation of the Addition Operation

Simple as it might be, the evaluation of addition is reflected on the ciphertext space as the multiplication with modulo.

```python
  def evalAdd(c1, c2, n):
    return c1 * c2 % (n*n)
```

<!-- ------------------------ -->
## Test the implementation

With the codes above, we can test the correctness of our implementation.

```python
  # generate keys
  n, g, Lambda, mu = generateKeys()
  print(f"Public key:       n = {n:10d},  g = {g:10d}")
  print(f"Private key: lambda = {Lambda:10d}, mu = {mu:10d}")

  # plaintext
  m1 = random.randint(0, n-1)
  m2 = random.randint(0, n-1)

  # ciphertext
  c1 = encrypt(m1, n, g)
  c2 = encrypt(m2, n, g)
  print(f"c1 = Encrypt({m1}) = {c1:18d} = 0x{c1:015x}")
  print(f"c2 = Encrypt({m2}) = {c2:18d} = 0x{c2:015x}")

  # evaluate addition
  c3 = evalAdd(c1, c2, n)
  print(f"c3 = c1 * c2 = {c3:18d} = 0x{c3:015x}")

  # decrypt
  d = decrypt(c3, Lambda, mu, n)
  print(f"Decrypt(c3) = {d} = {m1} + {m2} (mod {n})")
```
